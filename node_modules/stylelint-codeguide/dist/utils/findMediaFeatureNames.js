"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = findMediaFeatureNames;
var _cssTokenizer = require("@csstools/css-tokenizer");
var _cssParserAlgorithms = require("@csstools/css-parser-algorithms");
var _mediaQueryListParser = require("@csstools/media-query-list-parser");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/** @typedef {Array<import('@csstools/media-query-list-parser').MediaQuery>} MediaQueryList */
/** @typedef {import('@csstools/css-tokenizer').TokenIdent} TokenIdent */
/** @typedef {{ stringify: () => string }} MediaQuerySerializer */
var rangeFeatureOperator = /[<>=]/;

/**
 * Search a CSS string for Media Feature names.
 * For every found name, invoke the callback, passing the token as an argument.
 *
 * Found tokens are mutable and modifications made to them will be reflected in the output.
 *
 * This function supports some non-standard syntaxes like SCSS variables and interpolation.
 *
 * @param {string} mediaQueryParams
 * @param {(mediaFeatureName: TokenIdent) => void} callback
 *
 * @returns {MediaQuerySerializer}
 */
function findMediaFeatureNames(mediaQueryParams, callback) {
  var tokens = (0, _cssTokenizer.tokenize)({
    css: mediaQueryParams
  });
  var list = (0, _cssParserAlgorithms.parseCommaSeparatedListOfComponentValues)(tokens);
  var mediaQueryConditions = list.flatMap(function (listItem) {
    return listItem.flatMap(function (componentValue) {
      if (!(0, _cssParserAlgorithms.isSimpleBlockNode)(componentValue) || componentValue.startToken[0] !== _cssTokenizer.TokenType.OpenParen) {
        return [];
      }
      var blockTokens = componentValue.tokens();
      var mediaQueryList = (0, _mediaQueryListParser.parseFromTokens)(blockTokens, {
        preserveInvalidMediaQueries: true
      });
      return mediaQueryList.filter(function (mediaQuery) {
        return !(0, _mediaQueryListParser.isMediaQueryInvalid)(mediaQuery);
      });
    });
  });
  mediaQueryConditions.forEach(function (mediaQuery) {
    mediaQuery.walk(function (_ref) {
      var node = _ref.node;
      if ((0, _mediaQueryListParser.isMediaFeature)(node)) {
        var token = node.getNameToken();
        if (token[0] !== _cssTokenizer.TokenType.Ident) {
          return;
        }
        callback(token);
      }
      if ((0, _mediaQueryListParser.isGeneralEnclosed)(node)) {
        topLevelTokenNodes(node).forEach(function (token, i, topLevelTokens) {
          if (token[0] !== _cssTokenizer.TokenType.Ident) {
            return;
          }
          var nextToken = topLevelTokens[i + 1];
          var prevToken = topLevelTokens[i - 1];
          if ( /* Media Feature */!prevToken && nextToken && nextToken[0] === _cssTokenizer.TokenType.Colon || /* Range Feature */nextToken && nextToken[0] === _cssTokenizer.TokenType.Delim && rangeFeatureOperator.test(nextToken[4].value) || /* Range Feature */prevToken && prevToken[0] === _cssTokenizer.TokenType.Delim && rangeFeatureOperator.test(prevToken[4].value)) {
            callback(token);
          }
        });
      }
    });
  });

  // Serializing takes time/resources and not all callers will use this.
  // By returning an object with a stringify method, we can avoid doing
  // this work when it's not needed.
  return {
    stringify: function stringify() {
      return _cssTokenizer.stringify.apply(void 0, _toConsumableArray(tokens));
    }
  };
}

/** @param {import('@csstools/media-query-list-parser').GeneralEnclosed} node */
function topLevelTokenNodes(node) {
  var components = node.value.value;
  if ((0, _cssTokenizer.isToken)(components) || components.length === 0 || (0, _cssTokenizer.isToken)(components[0])) {
    return [];
  }

  /** @type {Array<import('@csstools/css-tokenizer').CSSToken>} */
  var relevantTokens = [];

  // To consume the next token if it is a scss variable
  var lastWasDollarSign = false;
  components.forEach(function (component) {
    // Only preserve top level tokens (idents, delims, ...)
    // Discard all blocks, functions, ...
    if (component && (0, _cssParserAlgorithms.isTokenNode)(component)) {
      if (component.value[0] === _cssTokenizer.TokenType.Delim && component.value[4].value === "$") {
        lastWasDollarSign = true;
        return;
      }
      if (lastWasDollarSign) {
        lastWasDollarSign = false;
        return;
      }
      relevantTokens.push(component.value);
    }
  });
  return relevantTokens;
}